{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"APIException","text":""},{"location":"#apiexception-standardised-exception-handling-for-fastapi","title":"APIException: Standardised Exception Handling for FastAPI","text":""},{"location":"#quick-installation","title":"\u26a1 Quick Installation","text":"<p>Download the package from PyPI and install it using pip: <pre><code>pip install apiexception\n</code></pre> </p> <p>If you already have Poetry and the uv together, you can install it with:</p> <pre><code>uv add apiexception\n</code></pre> <pre><code># You can also use the `uv` command to install it:\nuv pip install apiexception\n\n# Or, if you prefer using Poetry:\npoetry add apiexception\n</code></pre> <p>After installation, verify it\u2019s working: <pre><code>pip show apiexception\n</code></pre></p> <p>Now that you have the package installed, let\u2019s get started with setting up your FastAPI app. Just import the <code>register_exception_handlers</code> function from <code>apiexception</code> and call it with your FastAPI app instance to set up global exception handling: <pre><code>from api_exception import register_exception_handlers\nfrom fastapi import FastAPI\napp = FastAPI()\nregister_exception_handlers(app=app)\n</code></pre> That\u2019s it \u2014 copy, paste, and you\u2019re good to go. So easy, isn't it? </p> <p>Now all your endpoints will return consistent <code>success</code> and <code>error</code> responses, and your Swagger docs will be beautifully documented. Exception handling will be logged, and unexpected errors will return a clear JSON response instead of FastAPI\u2019s default HTML error page.</p>"},{"location":"#see-it-in-action","title":"\ud83d\udd0d See It in Action!","text":"<pre><code>from typing import List\nfrom fastapi import FastAPI, Path\nfrom pydantic import BaseModel, Field\nfrom api_exception import (\n    APIException,\n    BaseExceptionCode,\n    ResponseModel,\n    register_exception_handlers,\n    APIResponse\n)\n\napp = FastAPI()\n\n# Register exception handlers globally to have the consistent\n# error handling and response structure\nregister_exception_handlers(app=app)\n\n\n# Define your custom exception codes extending BaseExceptionCode\nclass CustomExceptionCode(BaseExceptionCode):\n    USER_NOT_FOUND = (\"USR-404\", \"User not found.\", \"The user ID does not exist.\")\n    INVALID_API_KEY = (\"API-401\", \"Invalid API key.\", \"Provide a valid API key.\")\n    PERMISSION_DENIED = (\"PERM-403\", \"Permission denied.\", \"Access to this resource is forbidden.\")\n\n\n# Let's assume you have a UserModel that represents the user data\nclass UserModel(BaseModel):\n    id: int = Field(...)\n    username: str = Field(...)\n\n\n# Create the validation model for your response.\nclass UserResponse(BaseModel):\n    users: List[UserModel] = Field(..., description=\"List of user objects\")\n\n\n@app.get(\"/user/{user_id}\",\n         response_model=ResponseModel[UserResponse],\n         responses=APIResponse.default()\n         )\nasync def user(user_id: int = Path()):\n    if user_id == 1:\n        raise APIException(\n            error_code=CustomExceptionCode.USER_NOT_FOUND,\n            http_status_code=401,\n        )\n    if user_id == 3:\n        a = 1\n        b = 0\n        c = a / b  # This will raise ZeroDivisionError and be caught by the global exception handler\n        return c\n\n    users = [\n        UserModel(id=1, username=\"John Doe\"),\n        UserModel(id=2, username=\"Jane Smith\"),\n        UserModel(id=3, username=\"Alice Johnson\")\n    ]\n    data = UserResponse(users=users)\n    return ResponseModel[UserResponse](\n        data=data,\n        description=\"User found and returned.\"\n    )\n</code></pre> <p>When you run your FastAPI app and open Swagger UI (<code>/docs</code>), your endpoints will display clean, predictable response schemas like this below:</p>"},{"location":"#-successful-api-response","title":"- Successful API Response?","text":"<pre><code>{\n  \"data\": {\n    \"users\": [\n      {\n        \"id\": 1,\n        \"username\": \"John Doe\"\n      },\n      {\n        \"id\": 2,\n        \"username\": \"Jane Smith\"\n      },\n      {\n        \"id\": 3,\n        \"username\": \"Alice Johnson\"\n      }\n    ]\n  },\n  \"status\": \"SUCCESS\",\n  \"message\": \"Operation completed successfully.\",\n  \"error_code\": null,\n  \"description\": \"User found.\"\n}\n</code></pre>"},{"location":"#-error-api-response","title":"- Error API Response?","text":"<p><pre><code>{\n  \"data\": null,\n  \"status\": \"FAIL\",\n  \"message\": \"User not found.\",\n  \"error_code\": \"USR-404\",\n  \"description\": \"The user ID does not exist.\"\n}\n</code></pre> In both cases, the response structure is consistent.</p> <ul> <li>In the example above, when the <code>user_id</code> is <code>1</code>, it raises an <code>APIException</code> with a custom <code>error_code</code>, the response is formatted according to the <code>ResponseModel</code> and it's logged automatically as shown below:</li> </ul> <p></p>"},{"location":"#-uncaught-exception-api-response","title":"- Uncaught Exception API Response?","text":"<p>What if you forget to handle an exception such as in the example above?</p> <ul> <li>When the <code>user_id</code> is <code>3</code>, the program automatically catches the <code>ZeroDivisionError</code> and returns a standard error response, logging it in a clean structure as shown below:</li> </ul> <pre><code>{\n  \"data\": null,\n  \"status\": \"FAIL\",\n  \"message\": \"Something went wrong.\",\n  \"error_code\": \"ISE-500\",\n  \"description\": \"An unexpected error occurred. Please try again later.\"\n}\n</code></pre> <p></p>"},{"location":"#clear-consistent-responses","title":"\ud83d\udca1 Clear &amp; Consistent Responses","text":"<ul> <li>\ud83d\udfe2 200: Success responses are always documented with your data model.</li> <li>\ud83d\udd11 401 / 403: Custom error codes &amp; messages show exactly what clients should expect.</li> <li>\ud83d\udd0d No guesswork \u2014 frontend, testers, and API consumers always know what to expect for both success and error cases.</li> <li>\ud83d\udcaa Even unexpected server-side issues (DB errors, unhandled exceptions, third-party failures) return a consistent JSON that follows your <code>ResponseModel</code>.</li> <li>\u274c No more raw HTML <code>500</code> pages! Every error is logged automatically for an instant audit trail.</li> </ul>"},{"location":"#frontend-integration-advantages","title":"\ud83d\udca1 Frontend Integration Advantages","text":"<p>In most APIs, the frontend must:</p> <ol> <li>Check the HTTP status code  </li> <li>Parse JSON  </li> <li>Extract data or error details  </li> </ol> <p>With APIException, every response follows the same schema: </p> <p>\u2192 Simply parse JSON once and check the <code>status</code> field (<code>SUCCESS</code> or <code>ERROR</code>).   \u2192 If <code>ERROR</code>, read <code>error_code</code> and <code>message</code> (or/and <code>description</code>) for full details. Since even the unexpected errors are formatted consistently, the frontend can handle them uniformly.</p> Flow Steps What the frontend checks Typical REST 1) Check HTTP status \u2192 2) Parse JSON \u2192 3) Branch for data/error Status code, JSON shape, error payload variations With APIException 1) Parse JSON once Read <code>status</code> \u2192 <code>SUCCESS</code> or <code>ERROR</code> <p>Client pattern:</p> <pre><code>// Example: fetch wrapper / interceptor\nconst res = await fetch(url, opts);\nconst body = await res.json();            // same shape for 2xx/4xx/5xx\n\nif (body.status === \"SUCCESS\") {\n  return body.data;                       // \u2705 consume data directly\n} else {\n  throw { code: body.error_code, message: body.description }; // \u274c unified error\n}\n</code></pre>"},{"location":"#backend-maintainability-advantages","title":"\ud83d\udca1 Backend Maintainability Advantages","text":"<ul> <li>Define each <code>CustomExceptionCode</code> once with <code>error_code</code>, <code>message</code>, and <code>description</code>.</li> <li>Logs become cleaner and easier to search.   \u2192 If another team reports an <code>error_code</code>, you can instantly locate it in logs.  </li> <li>Keeps backend code organized and avoids scattering error definitions everywhere.</li> <li>Share the <code>error_code</code> list with frontend teams for zero-guesswork integrations.</li> </ul>"},{"location":"#logging-debugging-flexibility","title":"\ud83d\udd0d Logging &amp; Debugging Flexibility","text":"<ul> <li>Toggle tracebacks on/off depending on the environment.</li> <li>Fully controllable logging: import, set log levels, or disable entirely.</li> <li>RFC 7808 support out of the box for teams that require standard-compliant error formats.</li> </ul> <p>Reduces boilerplate and speeds up integration. This is how APIException helps you build trustable, professional APIs from day one!</p>"},{"location":"#who-should-use-this","title":"\ud83d\udc65 Who should use this?","text":"<p>\u2705 FastAPI developers who want consistent success &amp; error responses. \u2705 Teams building multi-client or external APIs. \u2705 Projects where Swagger/OpenAPI docs must be clear and human-friendly. \u2705 Teams that need extensible error code management.</p> <p>If you\u2019re tired of:</p> <ul> <li> <p>Inconsistent response structures,</p> </li> <li> <p>Confusing Swagger docs,</p> </li> <li> <p>Messy exception handling,</p> </li> <li> <p>Finding yourself while trying to find the exception that isn't logged</p> </li> <li> <p>Backend teams asking \u201cWhat does this endpoint return?\u201d,</p> </li> <li> <p>Frontend teams asking \u201cWhat does this endpoint return in error?\u201d,</p> </li> </ul> <p>then this library is for you.</p>"},{"location":"#why-did-i-build-this","title":"\ud83c\udfaf Why did I build this?","text":"<p>After 4+ years as a FastAPI backend engineer, I\u2019ve seen how crucial a clean, predictable response model is. When your API serves multiple frontends or external clients, having different JSON shapes, missing status info, or undocumented error codes turns maintenance into chaos.</p> <p>So, this library:</p> <p>\u2705 Standardizes all success &amp; error responses, \u2705 Documents them beautifully in Swagger, \u2705 Provides a robust ExceptionCode pattern, \u2705 Adds an optional global fallback for unexpected crashes \u2014 all while keeping FastAPI\u2019s speed.</p>"},{"location":"#core-principles","title":"\u2728 Core Principles","text":"Principle Description \ud83d\udd12 Consistency Success and error responses share the exact same structure, improving reliability and DX. \ud83d\udcca Clear Docs OpenAPI/Swagger remains clean, accurate, and human-friendly. \ud83e\udeb6 Zero Boilerplate Configure once, then use anywhere with minimal repetitive code. \u26a1 Extensible Fully customizable error codes, handlers, and response formats for any project need."},{"location":"#benchmark","title":"\ud83d\udcca Benchmark","text":"<p>We benchmarked apiexception's <code>APIException</code> against FastAPI's built-in <code>HTTPException</code> using Locust with 200 concurrent users over 2 minutes. Both apps received the same traffic mix (\u224875% <code>/ok</code>, \u224825% <code>/error</code>).</p> Metric HTTPException (Control App) APIException (Test App) Avg Latency 2.00 ms 2.72 ms P95 Latency 5 ms 6 ms P99 Latency 9 ms 19 ms Max Latency 44 ms 96 ms Requests per Second (RPS) ~608.88 ~608.69 Failure Rate (<code>/error</code>) 100% (intentional) 100% (intentional) <p>Analysis - Both implementations achieved almost identical throughput (~609 RPS). - In this test, APIException\u2019s average latency was only +0.72 ms higher than HTTPException (2.42 ms vs 2.00 ms). - The P95 latencies were nearly identical at 5 ms and 6 ms, while the P99 and maximum latencies for APIException were slightly higher but still well within acceptable performance thresholds for APIs.</p> <p><code>Important Notice:</code> <code>APIException</code> automatically logs exceptions, while FastAPI\u2019s built-in <code>HTTPException</code> does not log them by default. Considering the extra logging feature, these performance results are very strong, showing that APIException delivers standardized error responses, cleaner exception handling, and logging capabilities without sacrificing scalability.</p>      HTTPException vs APIException \u2013 Latency Comparison    <p>Benchmark scripts and raw Locust reports are available in the benchmark directory.</p>"},{"location":"#next-steps","title":"\ud83d\udcda Next Steps","text":"<p>Ready to integrate? Check out: - \ud83d\ude80 Installation \u2014 How to set up APIException.</p> <ul> <li> <p>\u26a1  Quick Start \u2014 Add it to your project in minutes.</p> </li> <li> <p>\ud83e\udde9 Usage \u2014 Response models, custom codes, and fallback middleware.</p> </li> <li> <p>\ud83d\udcda Advanced \u2014 Swagger integration, logging, debugging.</p> </li> <li> <p>\ud83d\udd17 API Reference \u2014 Full reference docs.</p> </li> </ul>"},{"location":"changelog/","title":"\ud83d\udcdd Changelog","text":"<p>All notable changes to APIException will be documented here. This project uses Semantic Versioning.</p>"},{"location":"changelog/#0118-2025-08-17","title":"[0.1.18] - 2025-08-17","text":"<p>\u2705 Initial stable version</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Global logging control (<code>set_global_log</code>) with <code>log</code> param in <code>register_exception_handlers</code>.</li> <li>RFC7807 full support with <code>application/problem+json</code> responses.</li> <li>Automatic injection of <code>data: null</code> in OpenAPI error examples.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Dependency pins relaxed (<code>&gt;=</code> instead of strict <code>==</code>).</li> <li>Docstrings and examples updated (<code>use_response_model</code> \u2192 <code>response_format</code>).</li> <li>Unified error logging (no logs when <code>log=False</code>).</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fallback middleware now returns HTTP 500 instead of 422 for unexpected errors.</li> <li>Traceback scope bug fixed in handlers.</li> </ul>"},{"location":"changelog/#v0117-2025-08-11","title":"[v0.1.17] - 2025-08-11","text":"<ul> <li> <p><code>RFC 7807</code> standard support for consistent error responses (<code>application/problem+json</code>)</p> </li> <li> <p>OpenAPI (Swagger) schema consistency: nullable fields are now explicitly shown for better compatibility</p> </li> <li> <p><code>Poetry</code> support has been added for dependency management</p> </li> <li> <p><code>uv</code> support has been added.</p> </li> <li> <p>extra logger message param has been added to <code>APIException</code> for more detailed logging</p> </li> <li> <p><code>log_traceback</code> and <code>log_traceback_unhandled_exception</code> parameters have been added to <code>register_exception_handlers()</code> for more control over logging behavior</p> </li> <li> <p><code>log_exception</code> parameter has been added to <code>APIException</code> for more control over logging behavior</p> </li> <li> <p><code>log_message</code> parameter has been added to <code>APIException</code> for more control over logging behavior</p> </li> <li> <p>Logging now uses <code>add_file_handler()</code> to write logs to a file</p> </li> <li> <p>Logging improvements: now includes exception arguments in logs for better debugging</p> </li> <li> <p>Documentation has been updated.    </p> </li> <li> <p>Readme.md has been updated. </p> </li> </ul>"},{"location":"changelog/#v0116-2025-07-22","title":"[v0.1.16] - 2025-07-22","text":"<ul> <li> <p>setup.py has been updated.</p> </li> <li> <p>Documentation has been updated. </p> </li> <li> <p>Readme.md has been updated. </p> </li> </ul>"},{"location":"changelog/#v0115-2025-07-22","title":"[v0.1.15] - 2025-07-22","text":"<ul> <li> <p>setup.py has been updated.</p> </li> <li> <p>Project name has been updated. Instead of <code>APIException</code> we will use <code>apiexception</code> to comply with <code>PEP 625</code>.</p> </li> <li> <p>Documentation has been updated. </p> </li> <li> <p>Readme.md has been updated. </p> </li> </ul>"},{"location":"changelog/#v0114-2025-07-22","title":"[v0.1.14] - 2025-07-22","text":"<ul> <li> <p>setup.py has been updated.</p> </li> <li> <p>Project name has been updated. Instead of <code>APIException</code> we will use <code>apiexception</code> to comply with <code>PEP 625</code>.</p> </li> </ul>"},{"location":"changelog/#v0113-2025-07-21","title":"[v0.1.13] - 2025-07-21","text":"<ul> <li> <p>/examples/fastapi_usage.py has been updated.</p> </li> <li> <p>422 Pydantic error has been fixed in APIResponse.default()</p> </li> <li> <p>Documentation has been updated.</p> </li> <li> <p>Exception Args has been added to the logs.</p> </li> <li> <p>Readme has been updated. New gifs have been added.</p> </li> </ul>"},{"location":"changelog/#0112-2025-07-14","title":"[0.1.12] - 2025-07-14","text":"<ul> <li> <p>Documentation has been added to the project.</p> </li> <li> <p>More examples has been added.</p> </li> <li> <p><code>__all__</code> includes more methods.</p> </li> </ul>"},{"location":"changelog/#0111-2025-07-13","title":"[0.1.11] - 2025-07-13","text":"<p>\u2705 Stable release!</p> <ul> <li> <p>Global exception handlers with fallback middleware</p> </li> <li> <p>APIResponse for clean Swagger documentation</p> </li> <li> <p>Production-ready logging for all exceptions</p> </li> </ul>"},{"location":"changelog/#010-2025-06-25","title":"[0.1.0] - 2025-06-25","text":"<p>\ud83d\ude80 Prototype started!</p> <ul> <li> <p>Project scaffolding</p> </li> <li> <p><code>ResponseModel</code> has been added</p> </li> <li> <p><code>APIException</code> has been added</p> </li> <li> <p>Defined base ideas for standardizing error handling</p> </li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#all-in-one-example-application","title":"All in One Example Application","text":"<p>Below is a comprehensive example application demonstrating the capabilities of <code>api_exception</code>. This single file showcases how you can:</p> <ul> <li>Work with multiple FastAPI apps (API, Mobile, Admin) in the same project  </li> <li>Set different log levels based on the environment (e.g., INFO in dev, ERROR in prod)  </li> <li>Enable or disable tracebacks per application  </li> <li>Fully control logging behavior when raising <code>APIException</code> (log or skip logging)  </li> <li>Customize <code>DEFAULT_HTTP_CODES</code> to match your own status code mappings  </li> <li>Create and use custom exception classes with clean and consistent logging across the project  </li> <li>Use <code>APIResponse.custom()</code> and <code>APIResponse.default()</code> for flexible response structures  </li> <li>Demonstrate RFC 7807 problem details integration for standards-compliant error responses  </li> </ul> <p>This example serves as a one-stop reference to see how <code>api_exception</code> can be integrated into a real-world project while keeping exception handling consistent, configurable, and developer-friendly.  </p> <p>The below example can be found: View on GitHub</p> <pre><code>import os\nfrom typing import Literal\n\nimport uvicorn\nfrom fastapi import FastAPI, Path, APIRouter\nfrom pydantic import BaseModel, Field\nfrom pydantic_settings import BaseSettings\nfrom api_exception import (\n    APIException,\n    ExceptionStatus,\n    BaseExceptionCode,\n    ResponseModel,\n    register_exception_handlers,\n    APIResponse,\n    logger,\n    add_file_handler,\n    ResponseFormat,\n    DEFAULT_HTTP_CODES,\n    set_default_http_codes,\n)\n\n\n# -------------------------# FastAPI Production-Level Application\n# This is a production-level FastAPI application that demonstrates how to handle exceptions,\n# manage settings, and structure your application for scalability and maintainability.\n# It includes multiple services (admin, mobile, public API) with standardized error handling and logging.\n# I tried to show how to use the api_exception package in a production-level application.\n# -------------------------\n\n\n# The below Settings class is used to manage application settings.\n# It reads environment variables and provides default values.\n# Normally, you would have a config.py file for this purpose, but for simplicity, we define it here.\nclass Settings(BaseSettings):\n    IS_PRODUCTION: bool = os.getenv(\"IS_PRODUCTION\", \"false\").lower() in (\"true\", \"1\")\n    LOG_FILE_PATH: str = \"service.log\"\n\n\n\"\"\"\n# If you want to set default HTTP codes for different ExceptionStatus,\n# you can define them here. This is useful for standardizing responses across your application.\nDEFAULT_HTTP_CODES[\"ERROR\"] = 500  # Default HTTP code for ERROR status\n\n# or you can set it directly by uncommenting the below lines.\nset_default_http_codes({\n    ExceptionStatus.SUCCESS: 200,\n    ExceptionStatus.FAIL: 400,\n    \"UNAUTHORIZED\": 401,\n})\n\"\"\"\n\nsettings = Settings()\n\n# -------------------------\n# Logger level setting based on environment\n# -------------------------\n# Logs to console by default\n# logger.setLevel(\"WARNING\")  # Default to WARNING level\n# Set logger level can be based on the environment\nif settings.IS_PRODUCTION:\n    logger.setLevel(\"ERROR\")\nelse:\n    logger.setLevel(\"INFO\")\n\n# You can also add a file handler to log to a file.\nadd_file_handler(settings.LOG_FILE_PATH, level=logger.level)\n\n\n# -------------------------\n# Custom Exception Class that you can define in your code to make backend error responses standardized and predictable.\n# To use:\n# - Extend the `BaseExceptionCode` class\n# - Define constants as tuples with the following structure:\n#     (\n#         error_code: str,\n#         message: str,\n#         description: Optional[str],\n#         rfc7807_type: Optional[str],\n#         rfc7807_instance: Optional[str]\n#     )\nclass CustomExceptionCode(BaseExceptionCode):\n    USER_NOT_FOUND = (\"USR-404\", \"User not found.\")\n    INVALID_API_KEY = (\"API-401\", \"Invalid API key.\", \"Provide a valid API key.\")\n    PERMISSION_DENIED = (\"PERM-403\", \"Permission denied.\", \"Access to this resource is forbidden.\")\n    VALIDATION_ERROR = (\"VAL-422\", \"Validation Error\", \"Input validation failed.\")\n    TYPE_ERROR = (\"TYPE-400\", \"Type error.\", \"A type mismatch occurred in the request.\")\n    ITEM_NOT_FOUND = (\n        \"ITEM-404\", \"Item not found.\", \"The requested item does not exist.\",\n        \"https://example.com/problems/item-not-found\")\n    ITEM_MISSING = (\"ITEM-400\", \"Item missing.\", \"The item data is required but not provided.\",\n                    \"https://example.com/problems/item-missing\", \"/items\")\n\n\n# -------------------------\n# Shared Models\n# -------------------------\n# Normally, you would have a shared models file under /schemas such as items.py, but for simplicity, we define it here.\nclass Item(BaseModel):\n    name: str = Field(..., min_length=3, max_length=50)\n    price: float = Field(..., gt=0)\n\n\nclass ListOfItems(BaseModel):\n    items: list[Item] = Field(..., min_items=1, max_items=100,\n                              description=\"List of items with a minimum of 1 and maximum of 100 items.\")\n\n\nclass UserResponse(BaseModel):\n    id: int = Field(..., example=1, description=\"Unique identifier of the user\")\n    username: str = Field(..., example=\"Micheal Alice\", description=\"Username or full name of the user\")\n\n\n# -------------------------\n# APP Router\n# -------------------------\napp = FastAPI(title=\"monga-API\", docs_url=None, redoc_url=None)\napi_router = APIRouter()\napp.include_router(router=api_router)\n\n# -------------------------\n# Admin App\n# -------------------------\nadmin_app = FastAPI(\n    title=\"Admin Service\",\n    version=\"1.0.0\",\n    description=\"Admin service for managing items and users. Demonstrates exception handling scenarios.\",\n    docs_url=\"/docs\"\n)\n\nadmin_api_router = APIRouter(\n    responses={\n        400: {\"model\": ResponseModel[Literal[None]]},\n        422: {\"description\": \"Validation Error\"},\n    }\n)\nadmin_app.include_router(router=admin_api_router)\napp.mount(\"/admin/v1\", admin_app)\n\nregister_exception_handlers(\n    admin_app,\n    response_format=ResponseFormat.RESPONSE_MODEL,\n    use_fallback_middleware=True,\n    # This will use the fallback middleware to handle unhandled exceptions. Highly recommended.\n    log_traceback=not settings.IS_PRODUCTION,\n    include_null_data_field_in_openapi=True\n)\n\n# -------------------------\n# Mobile App\n# -------------------------\nmobile_app = FastAPI(title=\"Mobile Service\", version=\"1.0.0\")\napi_router = APIRouter(\n    prefix=\"/mobile/v1\",\n    tags=[\"mobile\"],\n)\nmobile_api_router = APIRouter(\n    responses={\n        400: {\"model\": ResponseModel[Literal[None]]},\n        422: {\"description\": \"Validation Error\"},\n    }\n)\nmobile_app.include_router(router=mobile_api_router)\napp.mount(\"/mobile/v1\", mobile_app)\n\nregister_exception_handlers(\n    mobile_app,\n    response_format=ResponseFormat.RESPONSE_MODEL,\n    use_fallback_middleware=True,\n    log_traceback=not settings.IS_PRODUCTION,\n    include_null_data_field_in_openapi=False\n)\n\n# -------------------------\n# Public API App\n# -------------------------\napi_app = FastAPI(title=\"Public API Service\", version=\"1.0.0\")\napi_api_router = APIRouter(\n    responses={\n        400: {\"model\": ResponseModel[Literal[None]]},\n        422: {\"description\": \"Validation Error\"},\n    }\n)\napi_app.include_router(router=api_api_router)\napp.mount(\"/api/v1\", api_app)\n\nregister_exception_handlers(\n    api_app,\n    response_format=ResponseFormat.RFC7807,\n    use_fallback_middleware=True,\n    log_traceback=not settings.IS_PRODUCTION,\n    log_traceback_unhandled_exception=not settings.IS_PRODUCTION,\n    include_null_data_field_in_openapi=True\n)\n\n\n@admin_app.post(\"/items\",\n                response_model=ResponseModel[Item],\n                responses=APIResponse.custom(\n                    (404, CustomExceptionCode.USER_NOT_FOUND),\n                    (400, CustomExceptionCode.TYPE_ERROR),\n                    (422, CustomExceptionCode.VALIDATION_ERROR)\n                ),\n                description=\"Create a new item. Raises various exceptions based on item name for demonstration purposes.\"\n                            \"if the item name is 'book', it raises a default 400 error with ITEM_NOT_FOUND code. \"\n                            \"if the item name is 'shoes', it raises a TypeError. \"\n                            \"if the item name is 'fridge', it raises a KeyError. \"\n                            \"if the item name is 'laptop', it raises an IndexError. \"\n                            \"if the item name is 'phone', it raises a ZeroDivisionError. \"\n                            \"if the item name is 'tablet', it raises a RuntimeError.\")\nasync def create_item(item: Item):\n    if item.name == \"book\":\n        raise APIException(\n            error_code=CustomExceptionCode.ITEM_NOT_FOUND,\n            log_message=f\"Item with name '{item.model_dump()}' not found.\",\n            # This will log extra message in the log file\n        )\n    if item.name == \"shoes\":\n        raise TypeError(\"Invalid type provided.\")\n    if item.name == \"fridge\":\n        raise KeyError(\"Missing key in dictionary.\")\n    if item.name == \"laptop\":\n        raise IndexError(\"List index out of range.\")\n    if item.name == \"phone\":\n        return 1 / 0  # This will raise ZeroDivisionError\n    if item.name == \"tablet\":\n        raise RuntimeError(\"Unexpected runtime issue.\")\n\n    data = Item(name=item.name, price=item.price)\n    return ResponseModel[Item](data=data,\n                               description=\"Items fetched successfully.\")\n\n\n@mobile_app.get(\"/items/{item_id}\",\n                response_model=ResponseModel[ListOfItems],\n                responses=APIResponse.default(),\n                description=\"Retrieve an item by its ID. Raises 404 if the item does not exist.\")\nasync def get_item(item_id: int = Path(..., gt=0)):\n    if item_id == 999:\n        logger.warning(f\"Mobile user requested non-existing item: {item_id}\")\n\n        raise APIException(\n            error_code=CustomExceptionCode.ITEM_MISSING,\n            description=\"Item not found\",\n            log_exception=False,  # Disable logging for this specific exception\n        )\n    data = [Item(name=f\"Item {item_id}\", price=item_id * 10.0),\n            Item(name=f\"Item {item_id + 1}\", price=(item_id + 1) * 10.0)]\n    return ResponseModel[ListOfItems](\n        data=ListOfItems(items=data),\n        status=ExceptionStatus.SUCCESS,\n        message=\"Items retrieved successfully\",\n        description=\"List of items fetched successfully.\"\n    )\n\n\n@api_app.get(\"/ping\",\n             response_model=ResponseModel,\n             responses=APIResponse.default(),\n             description=\"Ping endpoint to check if the API is running.\")\nasync def ping():\n    logger.info(\"Ping request received\")\n    return ResponseModel(data=\"pong\")\n\n\n@api_app.get(\"/user/{user_id}\",\n             response_model=ResponseModel[UserResponse],\n             responses=APIResponse.default()\n             )\nasync def get_user(user_id: int = Path(..., description=\"The ID of the user\")):\n    if user_id == 1:\n        raise APIException(\n            error_code=CustomExceptionCode.USER_NOT_FOUND,\n            http_status_code=404,\n        )\n    if user_id == 2:\n        raise TypeError(\"Invalid type provided.\")\n    if user_id == 3:\n        raise KeyError(\"Missing key in dictionary.\")\n    if user_id == 4:\n        raise IndexError(\"List index out of range.\")\n    if user_id == 5:\n        raise ZeroDivisionError(\"Cannot divide by zero.\")\n    if user_id == 6:\n        raise RuntimeError(\"Unexpected runtime issue.\")\n\n    data = UserResponse(id=user_id, username=\"John Doe\")\n    return ResponseModel(data=data)\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\n        \"examples.production_level:app\",\n        host=\"127.0.0.1\",\n        port=8000,\n        reload=True,\n    )\n</code></pre> <p>If you want to have a look at the examples, you can find them in the <code>examples</code> directory of the repository: View on GitHub</p>"},{"location":"installation/","title":"\ud83d\ude80 Installation","text":"<p>Set up APIException in minutes. Install it, plug it in and enjoy consistent API responses.</p>"},{"location":"installation/#install-via-pip","title":"\ud83d\udce6 Install via pip","text":"<p><pre><code>pip install apiexception\n</code></pre> This will install the latest stable release directly from PyPI.</p>"},{"location":"installation/#install-via-uv","title":"\u26a1 Install via uv","text":"<p>If you use uv for ultra-fast, isolated installs:</p> <pre><code>uv pip install apiexception\n</code></pre>"},{"location":"installation/#install-via-poetry","title":"\ud83c\udfaf Install via Poetry","text":"<p>If your project uses Poetry: <pre><code>poetry add apiexception\n</code></pre> Adds the package to your pyproject.toml and installs it automatically.</p>"},{"location":"installation/#requirements","title":"\u2705 Requirements","text":"<ul> <li>Python 3.10+</li> <li>FastAPI 0.75+</li> </ul>"},{"location":"installation/#quick-check","title":"\u2699\ufe0f Quick Check","text":"<p>After installation, verify it\u2019s working: <pre><code>pip show apiexception\n</code></pre></p> <p></p>"},{"location":"installation/#next-step","title":"\u27a1\ufe0f Next Step","text":"<p>Ready to plug it in?</p> <p>Jump to \u26a1 Quick Start for copy-paste integration examples!</p>"},{"location":"advanced/logging/","title":"\ud83e\udeb5 Logging &amp; Debug","text":"<p>Good exception handling is only half the battle \u2014 logging is what keeps your team sane in production.</p> <p>With APIException, unexpected errors don\u2019t just return a nice JSON response;</p> <p>they\u2019re also automatically logged so you always have a clear trail of what went wrong \u2014 and when needed, you can also log manually using the built-in logger for custom events or diagnostics.</p>"},{"location":"advanced/logging/#how-it-works","title":"\u2705 How It Works","text":"<p>Auto-logging: <pre><code>from api_exception import register_exception_handlers\nfrom fastapi import FastAPI\n\napp = FastAPI()\nregister_exception_handlers(\n    app=app,\n    use_fallback_middleware=True\n)\n</code></pre> You get two powerful behaviors:</p> <p>1\ufe0f\u20e3 All handled APIExceptions are logged with: - HTTP status - Exception code - Message - Context &amp; traceback</p> <p>2\ufe0f\u20e3 Unhandled exceptions (like DB errors, 3rd-party failures) are caught by the fallback middleware and: - Return a consistent JSON error response (ISE-500 by default) - The full traceback to your console or logging system</p> <p>Manual-Logging:</p> <p>If you want to log your own events (not just exceptions), you can use the built-in logger:</p> <p><pre><code>from api_exception.logger import logger\nlogger.warning(\"This will be logged to both console and file\")\nlogger.info(\"This INFO log will also be written to the file\"\n</code></pre> Also you can call add_file_handler to write log to file <pre><code>from api_exception.logger import add_file_handler,logger\nadd_file_handler(\"api_exception.log\", level=logging.DEBUG)\nlogger.warning(\"This will be logged to both console and file\")\n</code></pre></p>"},{"location":"advanced/logging/#example-output","title":"\u2699\ufe0f Example Output","text":"<p>When an exception happened, you\u2019ll see logs like:</p> <p></p> <p>When something unexpected happens, you\u2019ll see logs like:</p> <p></p>"},{"location":"advanced/logging/#tips","title":"\u26a1 Tips","text":"<p>\u2705 Use FastAPI\u2019s native logging module to pipe logs to your file, console, or external log aggregator (ELK, CloudWatch, etc.).</p> <p>\u2705 Combine this with FastAPI middlewares or your own log formatter if you want structured JSON logs.</p> <p>\u2705 For sensitive environments, make sure your logs do not expose user data.</p>"},{"location":"advanced/logging/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Want to see how fallback works? Check out \ud83e\ude93 Fallback Middleware</p> <p>\u2714\ufe0f Need better Swagger docs? Go to \ud83d\udcda Swagger Integration</p> <p>\u2714\ufe0f Haven\u2019t defined custom codes yet? Read \ud83d\uddc2\ufe0f Custom Exception Codes</p>"},{"location":"advanced/rfc7807/","title":"RFC 7807 Integration","text":""},{"location":"advanced/rfc7807/#rfc-7807-support","title":"\ud83e\udde9 RFC 7807 Support","text":"<p>Build trust with frontend developers and third-party integrators by adopting predictable, standardized error responses.</p> <p>RFC 7807 is an IETF standard that defines a consistent JSON structure for communicating error details over HTTP using the <code>application/problem+json</code> media type.</p> <p>Instead of returning arbitrary error objects, your API responses will include structured fields such as:</p> <ul> <li><code>type</code>: A URI reference that identifies the problem type</li> <li><code>title</code>: A short, human-readable summary of the problem</li> <li><code>status</code>: The HTTP status code</li> <li><code>detail</code>: A detailed explanation of the error</li> <li><code>instance</code>: A URI reference to the specific occurrence</li> </ul> <p>This structure makes your error messages machine-readable, self-descriptive, and easier to document and debug across all client types.</p> <p>RFC 7807 ensures every failure tells the same story \u2014 clearly, consistently, and predictably.</p>"},{"location":"advanced/rfc7807/#enable-rfc7807-globally","title":"\u2705 Enable RFC7807 Globally","text":"<p>To enable RFC 7807 response formatting across your application:</p> <pre><code>from api_exception import register_exception_handlers\nfrom api_exception.enums import ResponseFormat\nfrom fastapi import FastAPI\n\napp = FastAPI()\nregister_exception_handlers(\n    app, \n    response_format=ResponseFormat.RFC7807\n)\n</code></pre> <p>This will return error responses with the application/problem+json content type, formatted according to the RFC 7807 spec.</p>"},{"location":"advanced/rfc7807/#rfc7807-usage-example","title":"\ud83e\uddea RFC7807 Usage Example","text":"<pre><code>from api_exception import APIException, APIResponse\nfrom api_exception.enums import ResponseFormat\nfrom api_exception.models import ResponseModel\nfrom fastapi import FastAPI\nfrom .schemas import UserResponse\nfrom .exceptions import CustomExceptionCode\n\napp = FastAPI()\nregister_exception_handlers(app, response_format=ResponseFormat.RFC7807)\n\n@app.get(\n    \"/rfc7807\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.rfc7807(\n        (401, CustomExceptionCode.INVALID_API_KEY, \"https://example.com/errors/unauthorized\", \"/account/info\"),\n        (403, CustomExceptionCode.PERMISSION_DENIED, \"https://example.com/errors/forbidden\", \"/admin/panel\"),\n        (422, CustomExceptionCode.VALIDATION_ERROR, \"https://example.com/errors/unprocessable-entity\", \"/users/create\")\n    ),\n)\nasync def rfc7807_example():\n    raise APIException(\n        error_code=CustomExceptionCode.PERMISSION_DENIED,\n        http_status_code=403,\n    )\n</code></pre>"},{"location":"advanced/rfc7807/#example-error-response","title":"\ud83d\udcc4 Example Error Response","text":"<pre><code>{\n  \"type\": \"https://example.com/errors/forbidden\",\n  \"title\": \"Permission denied.\",\n  \"status\": 403,\n  \"detail\": \"Access to this resource is forbidden.\",\n  \"instance\": \"/admin/panel\"\n}\n</code></pre>"},{"location":"advanced/rfc7807/#notes","title":"\ud83d\udca1 Notes","text":"<ul> <li>APIResponse.rfc7807(*items) registers each HTTP error code with its corresponding RFC7807-compliant example. </li> <li>APIException uses the values defined in your CustomExceptionCode class to populate the fields of the RFC 7807 response.</li> <li>You can still return traditional JSON error responses by switching the response_format argument to ResponseFormat.RESPONSE_DICTIONARY.</li> </ul>"},{"location":"advanced/swagger/","title":"\ud83d\udcda Swagger Integration","text":"<p>One of the best parts of APIException is how cleanly it integrates with <code>Swagger (OpenAPI)</code>.</p> <p>Your success and error responses get documented with clear, predictable schemas \u2014 so your consumers, frontend teams, and testers know exactly what to expect.</p> <p>\ud83d\udca1 Unlike many solutions that omit <code>null</code> fields from example responses, APIException explicitly includes them. This ensures the full shape of the response model is preserved in the documentation, even when some values are <code>null</code>.</p>"},{"location":"advanced/swagger/#how-it-works","title":"\u2705 How it works","text":"<p>Use the <code>response_model</code> parameter for your success schema, and <code>APIResponse.default()</code> for default error code values, <code>APIResponse.custom(*items)</code> for custom error codes and <code>APIResponse.rfc7807(*items)</code> for RFC7807 Standart response with customer error codes to document expected error cases.</p>"},{"location":"advanced/swagger/#example-apiresponsedefault","title":"\u2699\ufe0f Example: <code>APIResponse.default()</code>","text":"<p>This documents your success response plus the default errors (400, 401, 403, 404, 422, 500).</p> <pre><code>from api_exception import APIResponse, ResponseModel\n@app.get(\"/user\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.default()\n)\n</code></pre> <p>When you open Swagger UI, it will show all the possible success and error cases:</p> <p></p>"},{"location":"advanced/swagger/#example-apiresponsecustom","title":"\u2699\ufe0f Example: <code>APIResponse.custom()</code>","text":"<p>Want more control?</p> <p>Use <code>APIResponse.custom()</code> to add your own specific error codes for each endpoint.</p> <p><pre><code>from api_exception import ResponseModel, APIResponse\n@app.get(\"/user\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.custom(\n        (401, CustomExceptionCode.INVALID_API_KEY),\n        (403, CustomExceptionCode.PERMISSION_DENIED)\n    )\n)\n</code></pre> In Swagger UI, your custom error cases will show up clearly alongside your success model:</p> <p></p>"},{"location":"advanced/swagger/#example-apiresponserfc7807","title":"\u2699\ufe0f Example: <code>APIResponse.rfc7807()</code>","text":"<p>The exception messages will be formatted as RFC 7807.</p> <pre><code>from schemas.response_model import ResponseModel\nfrom api_exception import APIResponse\n\n@app.get(\n    \"/rfc7807\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.rfc7807(\n        (401, CustomExceptionCode.INVALID_API_KEY, \"https://example.com/errors/unauthorized\", \"/account/info\"),\n        (403, CustomExceptionCode.PERMISSION_DENIED, \"https://example.com/errors/forbidden\", \"/admin/panel\"),\n        (422, CustomExceptionCode.VALIDATION_ERROR, \"https://example.com/errors/unprocessable-entity\", \"/users/create\")\n    ),\n)\n</code></pre> <p></p> <p>Want to go deeper? Read the RFC 7807 Standard</p>"},{"location":"advanced/swagger/#tips","title":"\u26a1 Tips","text":"<p>\u2705 APIResponse.default() is perfect for general endpoints that follow standard error codes.</p> <p>\u2705 APIResponse.custom(items) gives you precise control for business-specific exceptions. \u2705 Use APIResponse.rfc7807(items) to handle business-specific exceptions with full control, fully compliant with the RFC 7807 standard.</p> <p>No more incomplete or confusing Swagger docs!</p>"},{"location":"advanced/swagger/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Learn how to log exceptions properly: Check \ud83e\udeb5 Logging &amp; Debug</p> <p>\u2714\ufe0f Not using ResponseModel yet? See \u2705 Response Model</p> <p>\u2714\ufe0f Want to add fallback error handling? See \ud83e\ude93 Fallback Middleware</p> <p>\u2714\ufe0f Want to align your API with the RFC7807 standard? See \ud83e\ude93 RFC7807 Support</p>"},{"location":"reference/api/","title":"\ud83d\udd17 API Reference","text":"<p>This page lists the main classes, utilities, and helpers you\u2019ll use when working with APIException in your FastAPI project.</p> <p>Use this as a quick lookup when you want to check arguments, defaults, or core methods.</p>"},{"location":"reference/api/#available-exports","title":"\u2705 Available Exports","text":""},{"location":"reference/api/#responsemodel","title":"ResponseModel","text":"<p>\ud83d\udccc What it is:</p> <p>A generic, strongly-typed Pydantic model that standardizes all API responses.</p> <ul> <li>\u2705 Where to import:</li> </ul> <pre><code>from api_exception import ResponseModel\n</code></pre> <ul> <li> <p>\u2705 Key Fields:</p> <p>\u2022   <code>data</code>: your payload</p> <p>\u2022   <code>status</code>: SUCCESS, WARNING, FAIL</p> <p>\u2022   <code>message</code>: short summary</p> <p>\u2022   <code>error_code</code>: only set for failures</p> <p>\u2022   <code>description</code>: extra context for debugging</p> </li> </ul> <p><code>message</code> and <code>status</code> are Required fields and the rest is Optional. </p>"},{"location":"reference/api/#apiexception","title":"APIException","text":"<p>\ud83d\udccc What it is:</p> <p>Your main custom exception class \u2014 use this to raise predictable, documented API errors.</p> <ul> <li>\u2705 Where to import:</li> </ul> <pre><code>from api_exception import APIException\n</code></pre> <ul> <li> <p>\u2705 Key Args:</p> <p>\u2022   <code>error_code</code>: your BaseExceptionCode enum</p> <p>\u2022   <code>http_status_code</code>: maps to HTTP status</p> </li> </ul>"},{"location":"reference/api/#baseexceptioncode","title":"BaseExceptionCode","text":"<p>\ud83d\udccc What it is:</p> <p>Base class for defining your custom business exception codes.</p> <ul> <li>\u2705 Where to import:</li> </ul> <pre><code>from api_exception import BaseExceptionCode\n</code></pre>"},{"location":"reference/api/#apiresponse","title":"APIResponse","text":"<p>\ud83d\udccc What it is: A helper to document your Swagger/OpenAPI responses easily.</p> <ul> <li> <p>\u2705 Where to import: <pre><code>from api_exception import APIResponse\n</code></pre></p> </li> <li> <p>\u2705 Usage:</p> <p>\u2022   <code>APIResponse.default()</code> \u2192 adds standard 400\u2013500 errors.</p> <p>\u2022   <code>APIResponse.custom()</code> \u2192 add your own error codes with status.</p> </li> </ul>"},{"location":"reference/api/#register_exception_handlers","title":"register_exception_handlers","text":"<p>\ud83d\udccc What it is:</p> <p>Sets up global handlers to catch APIException and unexpected errors.</p> <ul> <li>\u2705 Where to import: <pre><code>from api_exception import register_exception_handlers\n</code></pre></li> </ul> <p>It's detailed in the Register Exception Handlers section.</p>"},{"location":"reference/api/#example","title":"\u26a1 Example","text":"<p>Here\u2019s how a typical setup might look:</p> <pre><code>from api_exception import (\n    APIException,\n    BaseExceptionCode,\n    ResponseModel,\n    APIResponse,\n    register_exception_handlers\n)\n</code></pre>"},{"location":"reference/api/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Haven\u2019t seen how to integrate yet? Go to \ud83d\ude80 Installation</p> <p>\u2714\ufe0f Want a quick end-to-end setup? Check out \u26a1 Quick Start</p> <p>\u2714\ufe0f See how to extend this with your own codes: Read \ud83d\uddc2\ufe0f Custom Exception Codes</p>"},{"location":"usage/custom_codes/","title":"\ud83d\uddc2\ufe0f Using Custom Exception Codes","text":"<p>Defining your own business-specific error codes keeps your API predictable, self-documenting, and easy to maintain.</p> <p>The <code>BaseExceptionCode</code> in APIException gives you a simple pattern to organize, reuse, and expand your error codes \u2014 all while keeping them consistent across your endpoints.</p>"},{"location":"usage/custom_codes/#why-use-custom-codes","title":"\u2705 Why Use Custom Codes?","text":"<p>\u2714\ufe0f Consistent error structure for your entire API \u2714\ufe0f Human-readable, unique codes for each failure scenario \u2714\ufe0f Easy for frontend or clients to handle specific cases</p>"},{"location":"usage/custom_codes/#example-define-and-raise","title":"\ud83d\udccc Example: Define and Raise","text":""},{"location":"usage/custom_codes/#define-your-codes","title":"\u2705 Define Your Codes","text":"<p>Create your own class by extending <code>BaseExceptionCode</code> and declare your error codes once:</p> <pre><code>from api_exception import BaseExceptionCode\n\nclass CustomExceptionCode(BaseExceptionCode):\n    # Format: KEY = (code, message, description)\n    USER_NOT_FOUND = (\"USR-404\", \"User not found.\", \"The user ID does not exist.\")\n    INVALID_API_KEY = (\"API-401\", \"Invalid API key.\", \"Provide a valid API key.\")\n    PERMISSION_DENIED = (\"PERM-403\", \"Permission denied.\", \"Access to this resource is forbidden.\")\n</code></pre>"},{"location":"usage/custom_codes/#use-them-with-apiexception","title":"\u2705 Use Them with APIException","text":"<p>Raise your custom error with full <code>typing</code>, <code>logging</code>, and <code>standardized</code> response:</p> <p><pre><code>from api_exception import APIException\n\nraise APIException(\n    error_code=CustomExceptionCode.USER_NOT_FOUND,\n    http_status_code=403\n)\n</code></pre> In the above example, if we raise the <code>APIException()</code>, the response will look like the below image. </p> <p>And it will automatically log the event. Log format can be seen in the below image.</p> <p></p>"},{"location":"usage/custom_codes/#how-it-looks-in-responses","title":"\ud83c\udff7\ufe0f How It Looks in Responses","text":"<p>\u2714\ufe0f Clear.</p> <p>\u2714\ufe0f Always consistent.</p> <p>\u2714\ufe0f Fully documented in Swagger UI.</p> <p>\u2714\ufe0f Automatically logged.</p>"},{"location":"usage/custom_codes/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Want to handle unexpected errors with a fallback? Read about \ud83e\ude93 Fallback Middleware</p> <p>\u2714\ufe0f Ready to integrate this with your Swagger docs? See \ud83d\udcda Swagger Integration</p> <p>\u2714\ufe0f Learn more about response structure? Check \u2705 Response Model</p>"},{"location":"usage/fallback/","title":"\ud83e\ude93 Fallback Middleware","text":"<p>A global fallback ensures your API always returns a predictable JSON response \u2014 even when something goes wrong that you didn\u2019t catch.</p> <p>When you enable <code>use_fallback_middleware=True</code>, APIException adds an extra middleware layer to handle any unhandled exceptions like database crashes, coding bugs, or third-party failures.</p>"},{"location":"usage/fallback/#why-use-it","title":"\u2705 Why use it?","text":"<ul> <li>No more raw <code>HTML 500 Internal Server Error</code> pages.</li> <li>Logs unexpected errors automatically \u2014 you get stack traces in logs, but your client gets a safe, clear JSON.</li> <li>Keeps your API response consistent no matter what goes wrong.</li> </ul>"},{"location":"usage/fallback/#how-to-enable","title":"\u2699\ufe0f How to enable","text":"<p>When you call <code>register_exception_handlers()</code>, just pass <code>use_fallback_middleware=True</code>.</p> <p><pre><code>from fastapi import FastAPI\nfrom api_exception import register_exception_handlers\n\napp = FastAPI()\n\nregister_exception_handlers(\n    app=app,\n    use_fallback_middleware=True\n)\n</code></pre> Simple as that! </p>"},{"location":"usage/fallback/#example-fallback-response","title":"\ud83d\udccc Example fallback response","text":"<p>Imagine your database goes down. Instead of an ugly HTML page, the fallback returns this: <pre><code>{\n  \"data\": null,\n  \"status\": \"FAIL\",\n  \"message\": \"Something went wrong.\",\n  \"error_code\": \"ISE-500\",\n  \"description\": \"An unexpected error occurred. Please try again later.\"\n}\n</code></pre> So frontend team can always handle errors the same way.</p>"},{"location":"usage/fallback/#tips","title":"\u26a1 Tips","text":"<p>\u2705 By default, fallback middleware is enabled (True).</p> <p>\u2705 You can disable it by passing <code>use_fallback_middleware=False</code>.</p> <p>\u2705 Works perfectly alongside your custom APIException raises.</p>"},{"location":"usage/fallback/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Want to integrate this with your Swagger docs? See \ud83d\udcda Swagger Integration</p> <p>\u2714\ufe0f Want to log exceptions in detail? Check \ud83e\udeb5 Logging &amp; Debug</p> <p>\u2714\ufe0f New here? Start with \ud83e\udde9 Response Model</p>"},{"location":"usage/quick_start/","title":"\u26a1 Quick Start","text":"<p>Get up and running with APIException in just a few minutes!</p>"},{"location":"usage/quick_start/#install-the-package","title":"\u2705 Install the Package","text":"<p>If you haven't done it yet, Let's first start by installing APIException from PyPI: <pre><code>pip install apiexception\n</code></pre></p>"},{"location":"usage/quick_start/#register-exception-handlers","title":"\u2705 Register Exception Handlers","text":"<p>Add the register_exception_handlers to your FastAPI app to automatically handle and standardize your responses:</p> <p><pre><code>from api_exception import register_exception_handlers\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nregister_exception_handlers(app=app)\n</code></pre> That\u2019s it! Your API now returns consistent success &amp; error responses, and unexpected server errors are automatically logged with a clear JSON output.</p>"},{"location":"usage/quick_start/#example-endpoint","title":"\u2705 Example Endpoint","text":"<p>Here\u2019s a minimal example: <pre><code>from fastapi import FastAPI, Path\nfrom pydantic import BaseModel, Field\nfrom api_exception import APIException, register_exception_handlers, ResponseModel, APIResponse, BaseExceptionCode\n\n\napp = FastAPI()\n\n# Register exception handlers globally to have the consistent\n# error handling and response structure\nregister_exception_handlers(app=app)\n\n# Create the validation model for your response\nclass UserResponse(BaseModel):\n    id: int = Field(..., example=1, description=\"Unique identifier of the user\")\n    username: str = Field(..., example=\"Micheal Alice\", description=\"Username or full name of the user\")\n\n\n# Define your custom exception codes extending BaseExceptionCode\nclass CustomExceptionCode(BaseExceptionCode):\n    USER_NOT_FOUND = (\"USR-404\", \"User not found.\", \"The user ID does not exist.\")\n\n\n@app.get(\"/user/{user_id}\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.default()\n)\nasync def user(user_id: int = Path()):\n    if user_id == 1:\n        raise APIException(\n            error_code=CustomExceptionCode.USER_NOT_FOUND,\n            http_status_code=401,\n        )\n    data = UserResponse(id=1, username=\"John Doe\")\n    return ResponseModel[UserResponse](\n        data=data,\n        description=\"User found and returned.\"\n    )\n</code></pre> The below video demonstrates what actually the example code does.</p> <p><code>Swagger UI</code> will be well structured. </p>"},{"location":"usage/quick_start/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Want to learn how to customize your responses? Check out \ud83e\udde9 Usage for response models, custom exception codes, and fallback middleware.</p> <p>\u2714\ufe0f Need to fine-tune Swagger docs? See \ud83d\udcda Advanced for better documentation &amp; logging tips.</p>"},{"location":"usage/register_exception_handlers/","title":"\ud83d\udee0 register_exception_handlers","text":"<p><code>register_exception_handlers(app, ...)</code> gives your FastAPI app consistent error handling, optional fallback for unhandled exceptions, structured logging, and an OpenAPI tweak that keeps response shapes stable for clients.</p>"},{"location":"usage/register_exception_handlers/#function-signature","title":"Function signature","text":"<pre><code>def register_exception_handlers(\n    app: FastAPI,\n    response_format: ResponseFormat = ResponseFormat.RESPONSE_MODEL,\n    use_fallback_middleware: bool = True,\n    log: bool = True,\n    log_traceback: bool = True,\n    log_traceback_unhandled_exception: bool = True,\n    include_null_data_field_in_openapi: bool = True,\n) -&gt; None:\n    ...\n</code></pre>"},{"location":"usage/register_exception_handlers/#parameters","title":"Parameters","text":"Parameter Type Required Default Effect <code>app</code> <code>FastAPI</code> Yes \u2014 The FastAPI instance to patch with handlers and middleware. <code>response_format</code> <code>ResponseFormat</code> No <code>ResponseFormat.RESPONSE_MODEL</code> Chooses how errors are serialized. Can be <code>RESPONSE_MODEL</code>, <code>RFC7807</code>, or <code>RESPONSE_DICTIONARY</code>. <code>use_fallback_middleware</code> <code>bool</code> No <code>True</code> Adds a middleware that catches any unhandled exception and returns a safe 500 JSON response. <code>log</code> <code>bool</code> No <code>True</code> Global toggle for all logging (handled + unhandled). If <code>False</code>, no logs are written at all. <code>log_traceback</code> <code>bool</code> No <code>True</code> If <code>True</code>, logs traceback for handled <code>APIException</code> errors. Useful in development, but can be noisy in prod. <code>log_traceback_unhandled_exception</code> <code>bool</code> No <code>True</code> If <code>True</code>, logs traceback for unhandled runtime errors caught by the middleware. <code>include_null_data_field_in_openapi</code> <code>bool</code> No <code>True</code> Ensures non-200 OpenAPI examples include <code>\"data\": null</code> for stable schemas in SDKs and validators."},{"location":"usage/register_exception_handlers/#responseformat-options","title":"ResponseFormat options","text":"Enum Description Typical use <code>RESPONSE_MODEL</code> Uses your internal <code>ResponseModel</code> schema. Default for product APIs that want one consistent shape. <code>RFC7807</code> Returns RFC 7807 Problem Details (<code>application/problem+json</code>). Public APIs and standards-driven clients. <code>RESPONSE_DICTIONARY</code> Returns plain dictionaries without models. Ultra lightweight responses or quick prototypes."},{"location":"usage/register_exception_handlers/#what-is-registered","title":"What is registered","text":"<ol> <li> <p>APIException handler    Catches <code>APIException</code>, logs request metadata and optional traceback, then serializes using <code>response_format</code>.</p> </li> <li> <p>Validation handler (only when <code>use_fallback_middleware=True</code>)    Catches <code>RequestValidationError</code> and returns 422 either as <code>ResponseModel</code> or RFC 7807.</p> </li> <li> <p>Fallback middleware (only when <code>use_fallback_middleware=True</code>)    Wraps each request to catch unhandled exceptions and return a uniform 500 response with logging.</p> </li> <li> <p>OpenAPI patch (only when <code>include_null_data_field_in_openapi=True</code>)    Modifies generated OpenAPI once to ensure non-200 examples include <code>\"data\": null</code> when missing.</p> </li> </ol>"},{"location":"usage/register_exception_handlers/#response-shapes","title":"Response shapes","text":""},{"location":"usage/register_exception_handlers/#response_model","title":"RESPONSE_MODEL","text":"<pre><code>{\n  \"status\": \"fail\",\n  \"message\": \"Permission denied\",\n  \"description\": \"You cannot access this resource.\",\n  \"error_code\": \"PER-403\",\n  \"data\": null\n}\n</code></pre>"},{"location":"usage/register_exception_handlers/#rfc-7807","title":"RFC 7807","text":"<p>Header: <code>Content-Type: application/problem+json</code> <pre><code>{\n  \"title\": \"Permission denied\",\n  \"description\": \"You cannot access this resource.\",\n  \"status\": 403,\n  \"type\": \"https://example.com/errors/forbidden\",\n  \"instance\": \"/admin/panel\"\n}\n</code></pre></p>"},{"location":"usage/register_exception_handlers/#response_dictionary","title":"RESPONSE_DICTIONARY","text":"<pre><code>{\n   \"data\": null,\n   \"status\": \"FAIL\",\n   \"message\": \"Permission denied\",\n   \"error_code\": \"PER-403\",\n   \"description\": \"You cannot access this resource.\"\n}\n</code></pre>"},{"location":"usage/register_exception_handlers/#quick-start","title":"Quick start","text":"<pre><code>from fastapi import FastAPI\nfrom api_exception import register_exception_handlers\n\napp = FastAPI()\nregister_exception_handlers(app)\n</code></pre>"},{"location":"usage/register_exception_handlers/#usage-patterns","title":"Usage patterns","text":""},{"location":"usage/register_exception_handlers/#minimal","title":"Minimal","text":"<pre><code>register_exception_handlers(app)\n</code></pre>"},{"location":"usage/register_exception_handlers/#production-with-file-logging-and-quieter-handled-errors","title":"Production with file logging and quieter handled errors","text":"<pre><code>from api_exception import register_exception_handlers, add_file_handler, logger\n\nadd_file_handler(\"prod_errors.log\")\nregister_exception_handlers(\n    app,\n    log_traceback=False,\n    log_traceback_unhandled_exception=True\n)\nlogger.setLevel(\"WARNING\")\n</code></pre>"},{"location":"usage/register_exception_handlers/#rfc-7807-outputs","title":"RFC 7807 outputs","text":"<pre><code>from api_exception import register_exception_handlers\nfrom custom_enum.enums import ResponseFormat\n\nregister_exception_handlers(\n    app,\n    response_format=ResponseFormat.RFC7807,\n    include_null_data_field_in_openapi=False\n)\n</code></pre>"},{"location":"usage/register_exception_handlers/#no-fallback-middleware","title":"No fallback middleware","text":"<pre><code>register_exception_handlers(\n    app,\n    use_fallback_middleware=False\n)\n</code></pre>"},{"location":"usage/register_exception_handlers/#lightweight-dict-responses","title":"Lightweight dict responses","text":"<pre><code>from custom_enum.enums import ResponseFormat\n\nregister_exception_handlers(\n    app,\n    response_format=ResponseFormat.RESPONSE_DICTIONARY\n)\n</code></pre>"},{"location":"usage/register_exception_handlers/#disable-all-logging-global","title":"Disable all logging (global)","text":"<pre><code>register_exception_handlers(\n    app,\n    log=False\n)\n</code></pre>"},{"location":"usage/register_exception_handlers/#endpoint-example","title":"Endpoint example","text":"<pre><code>from fastapi import FastAPI, Path\nfrom pydantic import BaseModel\nfrom api_exception import (\n    APIException, register_exception_handlers, ResponseModel,\n    BaseExceptionCode, APIResponse\n)\n\napp = FastAPI()\nregister_exception_handlers(app)\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n\nclass CustomExceptionCode(BaseExceptionCode):\n    USER_NOT_FOUND = (\"USR-404\", \"User not found.\", \"The user ID does not exist.\")\n    PERMISSION_DENIED = (\"PER-403\", \"Permission denied.\", \"You cannot access this resource.\")\n\n@app.get(\n    \"/user/{user_id}\",\n    response_model=ResponseModel[UserResponse],\n    responses=APIResponse.custom(\n        (403, CustomExceptionCode.PERMISSION_DENIED),\n        (404, CustomExceptionCode.USER_NOT_FOUND),\n    ),\n)\nasync def get_user(user_id: int = Path(...)):\n    if user_id == 1:\n        raise APIException(error_code=CustomExceptionCode.USER_NOT_FOUND, http_status_code=404)\n\n    return ResponseModel[UserResponse](\n        data=UserResponse(id=2, username=\"Jane Doe\"),\n        description=\"User found successfully.\"\n    )\n</code></pre>"},{"location":"usage/register_exception_handlers/#validation-errors","title":"Validation errors","text":"<p><code>RequestValidationError</code> is handled automatically and returns 422.</p> <p>ResponseModel mode <pre><code>{\n  \"status\": \"fail\",\n  \"message\": \"Validation Error\",\n  \"description\": \"Field required\",\n  \"error_code\": \"VAL-422\",\n  \"data\": null\n}\n</code></pre></p> <p>RFC 7807 mode <pre><code>{\n  \"title\": \"Validation Error\",\n  \"description\": \"Field required\",\n  \"status\": 422\n}\n</code></pre></p>"},{"location":"usage/register_exception_handlers/#openapi-behavior","title":"OpenAPI behavior","text":"<p>When <code>include_null_data_field_in_openapi=True</code>, the generator adds <code>\"data\": null</code> to non-200 examples that already include the standard error keys. This keeps SDKs and validators happy with a single, stable shape. The patched schema is cached on <code>app.openapi_schema</code>.</p>"},{"location":"usage/register_exception_handlers/#logging","title":"Logging","text":"<ul> <li>Every handled <code>APIException</code> logs path, method, client IP and optional traceback.</li> <li>Unhandled exceptions log a clear header block plus args and message.</li> <li>Use <code>add_file_handler(path)</code> to also write logs to a file.</li> <li>Tune verbosity with <code>logger.setLevel(\"DEBUG\" | \"INFO\" | \"WARNING\" | \"ERROR\")</code>.</li> </ul>"},{"location":"usage/register_exception_handlers/#troubleshooting","title":"Troubleshooting","text":"Symptom Likely cause Fix Swagger examples show no <code>data</code> field OpenAPI example lacks <code>data</code> Set <code>include_null_data_field_in_openapi=True</code> and restart the server. Responses not in expected shape Wrong <code>response_format</code> or endpoint <code>responses</code> override Verify <code>response_format</code> and your <code>APIResponse.*</code> helper usage. Logs are too noisy <code>log_traceback=True</code> in prod Set <code>log_traceback=False</code>, keep <code>log_traceback_unhandled_exception=True</code>. 422 responses not standardized Fallback disabled Set <code>use_fallback_middleware=True</code>."},{"location":"usage/response_model/","title":"\ud83e\udde9 Using <code>ResponseModel</code>","text":"<p>A clean, predictable response structure is the heart of a stable API.</p> <p>The <code>ResponseModel</code> in APIException makes sure every success and error response always has the same JSON format \u2014 easy to document, easy to parse, and friendly for frontend teams.</p>"},{"location":"usage/response_model/#how-it-works","title":"\u2705 How It Works","text":"<p>Every API response includes:</p> <ul> <li><code>data</code>: your actual payload  </li> <li><code>status</code>: one of <code>SUCCESS</code>, <code>WARNING</code>, <code>FAIL</code> </li> <li><code>message</code>: a short summary of the outcome  </li> <li><code>error_code</code>: only filled if there\u2019s an error  </li> <li><code>description</code>: extra context for debugging</li> </ul> <p>\ud83d\udc49 How to interpret:</p> <ul> <li> <p>If <code>data</code> is populated and <code>error_code</code> is null \u2192 treat as success</p> </li> <li> <p>If <code>error_code</code> is filled \u2192 treat as fail</p> </li> <li> <p>Your frontend can always rely on the <code>status</code> field to drive logic</p> </li> </ul>"},{"location":"usage/response_model/#example","title":"\ud83d\udccc Example","text":""},{"location":"usage/response_model/#import-and-use","title":"\u2705 Import and Use","text":"<pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel, Field\nfrom api_exception import (\n    ResponseModel,\n    APIResponse,\n    APIException,\n    ExceptionStatus,\n    BaseExceptionCode\n)\n\napp = FastAPI()\nregister_exception_handlers(app=app)\n\n\n'''\nCustom Exception Class that you can define in your code to make the backend responses look more standardized.\nJust extend the `BaseExceptionCode` and use it. \n'''\nclass CustomExceptionCode(BaseExceptionCode):\n    INVALID_API_KEY = (\"API-401\", \"Invalid API key.\", \"Provide a valid API key.\")\n\n\nclass ApiKeyModel(BaseModel):\n    api_key: str = Field(..., example=\"b2013852-1798-45fc-9bff-4b6916290f5b\", description=\"Api Key.\")\n\n\n@app.get(\n    \"/apikey\",\n    response_model=ResponseModel[ApiKeyModel],\n    responses=APIResponse.default()\n)\nasync def check_api_key(api_key: str):\n    if api_key != \"valid_key\":\n        raise APIException(\n            error_code=CustomExceptionCode.INVALID_API_KEY,\n            http_status_code=401,\n        )\n    data = ApiKeyModel(api_key=\"valid_key\")\n    return ResponseModel(\n        data=data,\n        status=ExceptionStatus.SUCCESS,\n        message=\"API key is valid\",\n        description=\"The provided API key is valid.\"\n    )\n</code></pre>"},{"location":"usage/response_model/#successful-response","title":"\u2705 Successful Response","text":"<pre><code>{\n  \"data\": {\n    \"api_key\": \"valid_key\"\n  },\n  \"status\": \"SUCCESS\",\n  \"message\": \"API key is valid\",\n  \"error_code\": null,\n  \"description\": \"The provided API key is valid.\"\n}\n</code></pre>"},{"location":"usage/response_model/#error-response","title":"\u274c Error Response","text":"<pre><code>{\n  \"data\": null,\n  \"status\": \"FAIL\",\n  \"message\": \"Invalid API key.\",\n  \"error_code\": \"API-401\",\n  \"description\": \"Provide a valid API key.\"\n}\n</code></pre> <p>No matter what happens \u2014 same shape, same fields, always predictable.</p>"},{"location":"usage/response_model/#why-use-it","title":"\u26a1 Why Use It?","text":"<p>\u2714\ufe0f Frontend teams can build once and trust the schema.</p> <p>\u2714\ufe0f No more scattered response shapes across endpoints.</p> <p>\u2714\ufe0f Swagger/OpenAPI docs stay clear and self-explanatory.</p> <p>\u2714\ufe0f Debugging becomes easy with <code>description</code> and <code>error_code</code>.</p>"},{"location":"usage/response_model/#next","title":"\ud83d\udcda Next","text":"<p>\u2714\ufe0f Ready to define your own error codes? Check out \ud83d\uddc2\ufe0f Custom Exception Codes</p> <p>\u2714\ufe0f Want to handle unexpected crashes globally? Learn about \ud83e\ude93 Fallback Middleware</p> <p>\u2714\ufe0f Want to see how this shows up in Swagger? Head over to \ud83d\udcda Swagger Integration</p>"}]}